# Services

## Service Types
- [Cluster IP Services](#clusterip-services)
- [NodePort Services](#nodeport-services)
- [LoadBalancer Services](#loadbalancer-service)
- [ExternalName Services](#externalname-services)

### ClusterIP Services
A ClusterIP Service is the default Kubernetes service type and is used for **internal communication within the cluster**. It exposes a stable virtual IP that is reachable only from inside the cluster, making it ideal for backend services such as databases, internal APIs, or microservices that should not be directly accessible from outside. Traffic sent to the ClusterIP is load-balanced across the selected pods via kube-proxy (or eBPF in modern setups), and service discovery is handled through internal DNS. From a GitOps and security perspective, ClusterIP encourages least-privilege networking, keeps internal traffic private, and works cleanly with service meshes and NetworkPolicies.

- Best for internal communication between microservices within cluster.
- Often combined with ingresses to expose applications via HTTP and HTTPS.

### NodePort Services
A NodePort Service exposes an application externally by opening a static port (typically in the 30000–32767 range) on every node in the cluster. Incoming traffic to < NodeIP >:< NodePort > is forwarded to the service and then load-balanced to the backing pods. This service type is often used for simple external access, debugging, or non-production environments, as it bypasses more advanced ingress and load-balancing mechanisms. In production GitOps workflows, NodePort is usually avoided because it couples networking to node IPs, complicates firewall rules, and lacks features like TLS termination, routing, and observability that ingress controllers or cloud load balancers provide.

- Useful for exposing a service externally without a load balancer.
- Often for development or testing

### LoadBalancer Service
A LoadBalancer Service in Kubernetes exposes an application to the outside world by provisioning an external load balancer and assigning it a public (or private) IP address that routes traffic to the service’s pods. In cloud environments (AWS, GCP, Azure), Kubernetes automatically integrates with the cloud provider to create and manage a managed Layer 4 load balancer (e.g., AWS NLB/ELB, GCP Cloud Load Balancer). External traffic hits the load balancer IP, is forwarded to a NodePort on cluster nodes, and then distributed to pods via kube-proxy or eBPF. 

This service type is simple and reliable for production, but it can be expensive, limited in routing capabilities (no path-based routing or TLS termination at L7), and less flexible than Ingress or Gateway APIs, making it best suited for exposing a small number of services that require direct, stable external access.

- Ideal for production environments where external access with load balancing is required.

### ExternalName Services
An ExternalName Service maps a Kubernetes service name to an external DNS name instead of routing traffic to pods. When queried via cluster DNS, it returns a CNAME record pointing to the external service (e.g., a managed database, SaaS API, or legacy system). No proxying or load balancing happens inside Kubernetes—clients connect directly to the external endpoint. This is particularly useful in GitOps and hybrid architectures where you want to decouple application configuration from environment-specific endpoints, allowing the same manifests to work across environments while external dependencies change via DNS. However, it does not support ports, selectors, or health checks, so resilience must be handled outside the cluster.

ExternalName service provides an abstraction for external services, allowing your applications within the cluster to communicate with them as if they were internal services. This is particularly useful for integrating with legacy systems or third-party APIs.

- Used to allow services within the cluster to access external services via a DNS name.