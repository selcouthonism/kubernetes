# Declarative Commands

```kubectl apply -f <filename> or <directory>```

This is the core declarative Kubernetes command. It tells Kubernetes to compare the desired state defined in the YAML file or directory with the current state in the cluster and then make only the necessary changes to reconcile the two. Kubernetes stores the last applied configuration as an annotation, enabling safe updates, diffs, and repeatable deployments. This is the preferred approach for production workflows.

```
kubectl apply -f nginx-pod.yaml
```
This command creates the Pod if it does not exist, or updates it if it already exists, based on the contents of nginx-pod.yaml. Kubernetes records the manifest in the Podâ€™s annotations and uses it as the reference point for future updates, making this operation idempotent (safe to run multiple times).


Task: Update the nginx image version in nginx-pod.yaml.
```
kubectl diff -f nginx-pod.yaml
```
This shows a preview of changes between the live resource in the cluster and the updated manifest file, without applying them. It helps you validate what will change, such as an updated container image, before modifying the running workload, which is especially important in production environments.

Apply changes:
```
kubectl apply -f nginx-pod.yaml
```
After updating the image version in the manifest, this command applies the change. Kubernetes updates the container configuration without deleting and recreating the Pod object itself; the Pod metadata remains, but the container is restarted with the new image. This behavior demonstrates declarative reconciliation rather than manual replacement.

Kubernetes does compare the current desired state (from your new YAML) with the last applied configuration (stored in the annotation) and the live state of the object in the cluster. This comparison allows it to determine exactly what changes need to be made.

If there are no differences between your new YAML and the last applied configuration, then **kubectl apply** will indeed do nothing. But if there are differences, it will calculate a "patch" to update only the changed fields, rather than recreating the entire resource.

```
kubectl describe pod nginx-pod
```
This command provides detailed runtime information about the Pod, including Events, start time, container states, and restart history. It is the primary tool for understanding what happened to a Pod over time and diagnosing issues such as image pull failures or restarts.

```
kubectl get pod nginx-pod -o yaml
```
This outputs the complete YAML definition of the Pod as stored in the cluster, including metadata, spec, and status. It also reveals the **kubectl.kubernetes.io/last-applied-configuration** annotation, which is how kubectl apply tracks and manages declarative changes.

```
kubectl delete -f nginx-pod.yaml
```
This deletes the resource defined in the manifest file, using the YAML as the source of truth for what should be removed. Kubernetes performs a graceful termination of the Pod, after which it is permanently removed since it is not managed by a controller like a Deployment.

#### Single Multi-resource Manifest
The ***---*** (three hyphens) is the key separator. When you place ***---*** between different Kubernetes object definitions in a single YAML file, kubectl apply understands that each section defines a separate resource.

```
kubectl apply -f nginx-pod-svc.yaml
```
This command applies all Kubernetes resources defined inside nginx-pod-svc.yaml to the cluster in a single declarative operation. Because the file contains multiple manifests separated by ***---***, kubectl parses each document independently and creates or updates each resource (for example, a Pod and a Service) in the correct order. Kubernetes then reconciles the desired state for both resources: the Pod is created or updated, and the Service is created or updated to select the Pod via labels, providing stable networking. Using a single multi-resource manifest ensures consistency, supports idempotent re-application, and reflects real-world best practice for managing related Kubernetes objects together.


Some best practices or strategies could be employed to manage a complex cluster configuration effectively using consolidation strategy, while mitigating the risk of unintended updates:

1. Keeping kind definitions in separate files: This is a very common and effective practice. It allows for modularity and makes it easier to manage individual components without affecting others. You can then use ***kubectl apply -f < directory >*** to apply all files in a directory.
2. Checking diff before apply: This is your safety net, ensuring you always know what changes will be made before they go live.
3. Using kubectl apply: Apply is designed for declarative management and handles updates intelligently.