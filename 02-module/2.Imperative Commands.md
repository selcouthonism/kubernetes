# Imperative Commands with Config Files (Manifest YAML)
In this flow, Kubernetes resources are defined declaratively in YAML files, but applied imperatively using ***kubectl create -f***. This approach combines:
- Declarative configuration (YAML describes desired state)
- Imperative execution (you explicitly create resources)

## Create Pod and Service

##### Create Pod using a manifest
```
kubectl create -f nginx-pod.yaml
```
This command:
- Reads the nginx-pod.yaml manifest
- Sends it to the Kubernetes API server
- Creates a Pod resource exactly as defined in the YAML

The manifest typically includes:
- Pod name and labels
- Container image (nginx)
- Exposed container ports

Once created, the scheduler assigns the Pod to a node and the container starts.

##### Create Service using a manifest
```
kubectl create -f nginx-svc.yaml
```
This creates a Service resource that exposes the Pod defined earlier.

The Service:
- Selects Pods using labels
- Provides a stable ClusterIP
- Optionally exposes a NodePort for external access

This decouples clients from the Pod’s lifecycle and IP changes.

#### Test Service Connectivity from Another Pod

##### Run an interactive Alpine Pod
```
kubectl run -it alpine --image=alpine:3.20 sh
apk --update add curl
```
This starts a lightweight debug Pod and installs curl to test networking inside the cluster. This is a standard operational debugging technique.

This is a common operational pattern for:
- Verifying Service routing
- Testing DNS resolution
- Debugging network issues inside the cluster

##### Find Service IP address
```
kubectl describe service nginx-svc
```
This shows detailed Service configuration and runtime data.
```
IP:                       10.101.46.165
IPs:                      10.101.46.165
Port:                     <unset>  80/TCP
TargetPort:               80/TCP
NodePort:                 <unset>  30549/TCP
```
- **ClusterIP** is the internal virtual IP used by Pods
- **TargetPort** maps traffic to the container’s port
- **NodePort** exposes the Service externally via node IPs

##### List Services
```
kubectl get services
```
Provides a summarized view of all Services in the namespace:
```
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
nginx-svc    NodePort    10.101.46.165   <none>        80:30549/TCP   5m12s
```
This confirms the Service is created and reachable.

##### Call NGINX Service from Alpine Pod
```
curl 10.101.46.165
```
This sends traffic to the Service via its ClusterIP, which:
- Is intercepted by kube-proxy
- Load-balanced to the matching Pod(s)
- Forwards traffic to the container’s port

##### Call NGINX Service via DNS
```
curl nginx-svc
```
This uses Kubernetes DNS (CoreDNS) to resolve the Service name nginx-svc to its ClusterIP. This is the recommended way for Pod-to-Pod communication.

#### Delete Pod Using Manifest
```
kubectl delete -f nginx-pod.yaml
kubectl delete -f nginx-pod.yaml -f nginx-svc.yaml
```
This deletes the Pod resource defined in the YAML file.
- The Service remains
- Endpoints are removed automatically
- Requests to the Service will fail until a new matching Pod is created

This demonstrates how Services outlive Pods and provide stable networking.

## Generate manifest files with kubectl (dry-run + YAML output)
This command uses kubectl to generate a Kubernetes resource manifest without creating it in the cluster. The **--dry-run=client** flag tells kubectl to simulate the operation locally, while **-o yaml** outputs the resulting resource definition in YAML format. In practice, this turns kubectl into a manifest generator, allowing you to review, customize, and version-control the YAML before applying it, which is a safer and more production-ready workflow than creating resources directly.

The key flags here are:
- **--dry-run=client** → do not create anything in the cluster
- **-o yaml** → output the resource definition as YAML

##### Generate a Pod manifest
```
kubectl run color-api --image=selcouthonism/color-api:1.0.0 --dry-run=client -o yaml
```
- Simulates creating a Pod named color-api
- Uses the specified container image
- Outputs the generated Pod manifest in YAML format
- Does not send anything to the API server

##### Generate a Service manifest
```
kubectl expose pod nginx-pod --type=NodePort --port=80 --dry-run=client -o yaml
```
- Simulates exposing an existing Pod (nginx-pod)
- Creates a Service definition of type NodePort
- Maps Service port 80 to the Pod’s target port
- Outputs the Service YAML instead of creating it

## Kubernetes Manifest File
```
kubectl get pod nginx-pod -o yaml
```
This command retrieves the **full YAML representation of the existing Pod** named nginx-pod from the Kubernetes API server and prints it to standard output. Using **-o yaml** exposes both the spec (desired configuration) and the status (runtime state, assigned node, Pod IP, conditions, etc.), making it useful for debugging, auditing, or exporting the Pod definition as a reference when creating new manifests or troubleshooting discrepancies between desired and actual state.

### Replacing a Pod in Kubernetes

When you update the NGINX image version in nginx-pod.yaml and run:
```
kubectl replace -f nginx-pod.yaml
```
Kubernetes returns an error because Pods are largely immutable. Once a Pod is created, most fields in its spec—including the container image cannot be changed. The replace command attempts to update the existing Pod in place, but Kubernetes rejects the request since modifying the Pod spec violates immutability rules.

To apply the change, you must recreate the Pod:
```
kubectl delete -f nginx-pod.yaml
kubectl create -f nginx-pod.yaml
```
This sequence deletes the old Pod and creates a new one using the updated manifest, allowing the new image version to be used. In real-world scenarios, this limitation is why Pods are usually managed by higher-level controllers like Deployments, which handle Pod replacement and rolling updates automatically without downtime.