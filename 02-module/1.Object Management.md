# Object Management
In the Kubernetes ecosystem, object management is the process of defining, creating, and maintaining the lifecycle of resources like Pods, Deployments, and Services. As you scale, the method you choose significantly impacts your team's velocity and the reliability of your infrastructure.

Here is a breakdown of the three primary management techniques.

## 1. Imperative Management with kubectl Commands
This is the "live" approach. You tell the Kubernetes API exactly what action to take immediately using specific verbs.

You use commands like ***kubectl run***, ***kubectl expose***, or ***kubectl scale*** directly in the terminal It is best for quick troubleshooting, learning, or one-off development tasks.

Pros: Fast; no need to write YAML for simple tasks.

Cons: No audit trail. There is no record of what changed or why, making it impossible to replicate the environment exactly from scratch.

Example: kubectl run nginx --image=nginx --port=80

- kubectl create < resource > [config]
- kubectl delete < resource >
- kubectl expose < resource > < name >
- kubectl [get | describe | logs ]

## 2. Imperative Management with Config Files
This is a hybrid approach. You still use "action" verbs, but you point them at a specific YAML or JSON file.

You define your object in a file and use commands like ***kubectl create***, ***kubectl replace***, or ***kubectl delete***.

**The "Replace" Problem:** If you want to update an object, you must use kubectl replace. However, this requires you to provide the entire updated spec. If someone else changed a field in the cluster manually, your replace command might overwrite their changes or fail.

It is best for small projects or scripts where you want some version control but aren't ready for full automation.

Pros: Files can be stored in Git; more repeatable than raw commands.

Cons: Management is manual. You have to remember if the object already exists (to choose between create or replace).

Example: kubectl create -f deployment.yaml

- kubectl create -f < filename >
- kubectl delete -f < filename >
- kubectl replace -f < filename >
- kubectl [get | describe | logs ]

## 3. Declarative Management with Config Files
This is the industry standard for production environments and the foundation of GitOps.

Instead of telling Kubernetes what to do (create/replace), you tell it what you want the state to be. You use the ***kubectl apply*** command on a file or a whole directory.

The declarative management is essential because it treats infrastructure as code (IaC). If a cluster dies, you don't need to remember 50 kubectl commands; you simply point ***kubectl apply*** at your configuration repository, and the cluster self-heals to the state defined in your files.

**The Reconciliation Loop:** Kubernetes looks at the live object, looks at your file, and calculates the difference (a three-way merge). It then applies only the necessary changes to reach the desired state.

It is best for production, CI/CD pipelines, and large-scale deployments.

Pros: Idempotent (you can run it 100 times and the result is the same), supports concurrent edits by different team members, and is fully auditable via Git.

Cons: Partitial updates are more complex to understand and debug. Live object's state might not be entirely reflected in the configuration files.

- kubectl apply -f < filename >
- kubectl diff -f < filename >
- kubectl delete -f < filename >
- kubectl [get | describe | logs ]

**Imperative vs Declarative:**

In imperative management, you're essentially telling Kubernetes how to do something step-by-step, while in declarative management, you're defining what you want the state of your system to be, and Kubernetes figures out the how.

## Manifest File
A manifest file is a declarative "blueprint" that tells the cluster exactly how a resource should look and behave. Rather than executing a sequence of manual commands, DevOps engineers define the desired state of infrastructure—such as the number of replicas, container images, and network policies—within these YAML or JSON files. This approach allows the manifest to serve as a persistent record of intent, which Kubernetes’ control plane constantly works to maintain through its reconciliation loops.

The manifest files are the cornerstone of Infrastructure as Code (IaC) and GitOps. By storing these files in version control like Git, teams gain a clear audit trail of every change made to the environment, enabling automated CI/CD pipelines and the ability to reproduce entire clusters from scratch. They abstract the complexity of individual cloud providers, providing a standardized way to manage workloads across any environment, whether it's a local dev machine or a massive production cluster.

### The Four Required Root Fields

Every Kubernetes manifest must contain these four top-level fields to be considered valid by the API server:

#### apiVersion: 
This specifies which version of the Kubernetes API you are using to create the object. Since Kubernetes evolves quickly, different resources may belong to different API groups (e.g., v1 for core Pods, apps/v1 for Deployments, or networking.k8s.io/v1 for Ingress). Using the correct version ensures compatibility with the cluster's current features.

#### kind:
This identifies the type of object you want to create. It tells Kubernetes which controller should handle the request. Common values include Pod, Service, Deployment, ConfigMap, or Namespace.

#### metadata: 
This section contains data that helps uniquely identify and organize the object. At a minimum, it must include a name string. It is also where you define labels (for grouping and selecting resources), annotations (for non-identifying metadata), and the namespace where the object should reside.

#### spec: 
This is the most critical part of the manifest as it defines the desired state. The fields inside spec vary entirely based on the kind. For a Deployment, the spec includes the number of replicas and the pod template; for a Service, it includes the ports and selectors. It is essentially your specific set of instructions for how the resource should operate.