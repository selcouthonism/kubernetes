# ReplicaSets

## nginx-rs.yaml
```
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80  
```
This YAML file defines a ReplicaSet that ensures a specified number of identical NGINX Pods are running at all times. Hereâ€™s a breakdown of each section and its role in Kubernetes:

```apiVersion: apps/v1```
Specifies the Kubernetes API group and version used for workload controllers like ReplicaSet, Deployment, and DaemonSet.

```kind: ReplicaSet```
Declares that this resource is a ReplicaSet, whose responsibility is to maintain a fixed number of Pod replicas and replace them if they fail or are deleted.

```metadata.name: nginx-replicaset```
Gives the ReplicaSet a unique name within the namespace so it can be managed and referenced by Kubernetes.

```spec.replicas: 3```
Instructs Kubernetes to keep exactly three Pods running that match the selector. If one Pod crashes or is deleted, the ReplicaSet automatically creates a replacement.

```spec.selector.matchLabels```
Defines how the ReplicaSet identifies which Pods it manages. Any Pod with the **label app: nginx** is considered part of this ReplicaSet. This selector must match the labels in the Pod template.

```spec.template```
Describes the Pod template used to create new Pods. This is the blueprint the ReplicaSet uses whenever it needs to create or replace a Pod.

```template.metadata.labels```
Applies labels (app: nginx) to Pods created by this ReplicaSet so they match the selector and can be targeted by Services.

```template.spec.containers```
Defines the container(s) that run inside each Pod.

```containers.name: nginx```
Names the container within the Pod.

```containers.image: nginx:latest```
Specifies the container image to run. Using latest means the image version is not fixed, which is generally discouraged in production due to unpredictability.

```containers.ports.containerPort: 80```
Documents that the container listens on port 80. This is informational for Kubernetes and commonly used by Services to route traffic.

### Create a Replica Set
```
kubectl apply -f nginx-rs.yaml
```
This command creates a ReplicaSet from the declarative manifest nginx-rs.yaml. Kubernetes stores the desired state (for example, replicas: 3 and the Pod template) and immediately reconciles the cluster by creating the required number of Pods that match the selector defined in the ReplicaSet.

#### Get ReplicaSet information
```
kubectl get rs
kubectl get rs --watch
```
These commands list all ReplicaSets in the namespace, showing desired vs. current replicas. The **--watch** flag streams real-time updates, allowing you to observe changes such as Pod creation, deletion, or scaling as they happen.

#### Get Pod information
```
kubectl get pods
kubectl get pods --watch
```
These commands list the Pods managed by the ReplicaSet. Using **--watch** lets you see Pods being created, terminated, or replaced in real time, which is especially useful for understanding ReplicaSet behavior.

Initial Pods created by the ReplicaSet:
```
NAME                     READY   STATUS    RESTARTS   AGE
nginx-replicaset-4q2ng   1/1     Running   0          33s
nginx-replicaset-7c66w   1/1     Running   0          33s
nginx-replicaset-vfm98   1/1     Running   0          33s
```
These Pods were automatically created by the ReplicaSet to satisfy the replicas: 3 requirement. The random suffixes ensure unique Pod names while sharing the same template and labels.

#### Describe the ReplicaSet
```
kubectl describe rs nginx-replicaset
```
This command shows detailed information about the ReplicaSet, including the selector, Pod template, desired/current replica counts, and recent Events. It clearly shows how the ReplicaSet is enforcing the desired number of Pods.

#### Delete a Pod (self-healing behavior)
```
kubectl delete pod nginx-replicaset-4q2ng
```
When one Pod is manually deleted, the ReplicaSet immediately detects that the number of running Pods is below the desired count and creates a new Pod automatically. This demonstrates the self-healing nature of ReplicaSets.

Replacement Pod created:
```
NAME                     READY   STATUS    RESTARTS   AGE
nginx-replicaset-7c66w   1/1     Running   0          2m
nginx-replicaset-d2cjn   1/1     Running   0          23s
nginx-replicaset-vfm98   1/1     Running   0          2m
```
The new Pod replaces the deleted one, restoring the replica count to three. The ReplicaSet does not reuse the old Pod; it creates a brand-new Pod from its template.

### Update the ReplicaSet image
Update the image in nginx-rs.yaml from nginx:latest to nginx:1.27.0-alpine and reapply the manifest.
```
kubectl apply -f nginx-rs.yaml
```
Although the ReplicaSet template is updated, **existing Pods are not replaced automatically**. ReplicaSets do not perform rolling updates; they only ensure the correct number of Pods exist.

#### Verify Pods still use the old image
```
kubectl describe pod nginx-replicaset-7c66w | grep Image
kubectl describe pod nginx-replicaset-vfm98 | grep Image
```
These commands confirm that the existing Pods are still running nginx:latest, proving that ReplicaSet updates do not affect already-running Pods.

#### Delete an old Pod after the update
```
kubectl delete pod nginx-replicaset-7c66w
```
When an old Pod is deleted, the ReplicaSet creates a new Pod using the updated template, which now specifies nginx:1.27.0-alpine.

```
NAME                     READY   STATUS    RESTARTS   AGE
nginx-replicaset-555v6   1/1     Running   0          18s
nginx-replicaset-d2cjn   1/1     Running   0          3m
nginx-replicaset-vfm98   1/1     Running   0          3m
```
#### Mixed image versions observed
The newly created Pod (nginx-replicaset-555v6) runs nginx:1.27.0-alpine, while the older Pod continues running nginx:latest. This results in mixed versions, which highlights why ReplicaSets are rarely used directly for updates and why **Deployments** are preferred. Deployments handle controlled rolling updates automatically.

```
kubectl describe pod nginx-replicaset-555v6 | grep Image
kubectl describe pod nginx-replicaset-vfm98 | grep Image
```

### 

#### Delete the ReplicaSet
```
kubectl delete -f nginx-rs.yaml
```
This command deletes the ReplicaSet defined in nginx-rs.yaml. When a ReplicaSet is removed, Kubernetes also deletes all Pods managed by that ReplicaSet, because they are owned by it. This cleanly removes both the controller and its workloads, returning the cluster to a state where no Pods from that ReplicaSet are running.

#### Create a single NGINX Pod
```
kubectl create -f nginx-pod.yaml
```
This command creates a standalone Pod from the nginx-pod.yaml manifest. The Pod runs independently without any controller managing it, meaning it is not self-healing. If the Pod is deleted or crashes, Kubernetes will not recreate it automatically.

#### Create a ReplicaSet (creates only two Pods)
```
kubectl create -f nginx-rs.yaml
```
This command creates a ReplicaSet that is configured to run two replicas of NGINX. The ReplicaSet creates only two Pods because it detects that an existing Pod already **matches its label selector** (the standalone NGINX Pod), so it counts that Pod toward the desired replica count instead of creating a third one. This demonstrates how ReplicaSets adopt existing Pods that match their selector, which is why label design must be handled carefully.

#### Delete a single NGINX Pod
```
kubectl delete -f nginx-pod.yaml
```
Kubernetes deletes the standalone NGINX Pod defined in that manifest, but because a ReplicaSet is already managing Pods with the **same label selector**, it immediately detects that the number of matching Pods has dropped below the desired replica count. As a result, the ReplicaSet automatically creates a new Pod to restore the desired state, demonstrating the self-healing behavior of ReplicaSets and how they continuously reconcile actual state with the declared replica count.