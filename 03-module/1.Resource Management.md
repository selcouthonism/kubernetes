# Resource Management
-[Labels and Selectors](#labels-and-selectors)
-[Annotations](#annotations)

## Labels and Selectors
Labels and selectors enable Kubernetes to remain declarative and dynamic by ensuring that workloads automatically adapt as Pods scale, restart, or move across nodes. They are critical for service discovery, load balancing, rolling updates, and policy enforcement. Designing a consistent labeling strategy early is essential for operating Kubernetes clusters at scale.

### Labels
Labels are simple key–value pairs attached to Kubernetes objects such as Pods, Services, Deployments, and Nodes. They are used to identify attributes of resources (for example, app=color-api, env=prod, tier=backend) and have no inherent meaning to Kubernetes unless referenced by selectors. Labels are designed to be flexible and changeable, making them ideal for representing logical groupings, versions, environments, or ownership without embedding this information into resource names.

### Selectors
Selectors are queries used by Kubernetes components (like Services, Deployments, and ReplicaSets) to select a subset of objects based on their labels. Instead of referencing resources by name or IP, selectors dynamically match objects that satisfy certain label conditions. This enables loose coupling, automatic updates when Pods are recreated, and scalable workload management.

#### Equality-Based Selectors
Equality-based selectors match labels using exact comparisons. They support three operators: **=**, **==**, and **!=**. These selectors are simple and commonly used in Services and ReplicaSets to target Pods with a specific label value, such as app=color-api or env!=dev. Equality-based selectors are easy to understand and efficient, but they are limited to single-value comparisons.

Example via yaml:
```
selector:
  matchLabels:
    app: color-api
    tier: backend
```

Example via CLI:
```
kubectl get pods -l app=color-api
```

#### Set-Based Selectors
Set-based selectors allow matching labels against a set of values using operators like **In**, **NotIn**, **Exists**, and **DoesNotExist**. They provide more expressive power, enabling selection of resources that belong to multiple versions, environments, or tiers without duplicating selectors. Set-based selectors are commonly used in advanced scheduling, policy enforcement, and operational queries. Supported only by certain Kubernetes objects(e.g. Jobs, Deployments, ReplicaSets)

Example via yaml:
```
selector:
  matchExpressions:
    - key: env
      operator: In
      # values: [prod, staging]
      values:
        - prod
        - staging
```

Example via CLI:
```
kubectl get pods -l 'env in (prod,staging)'
```

### Examples
#### Create backend color-api pod and frontend nginx pod
```
kubectl apply -f color-api.yaml
```
This command sends the declarative resource definition(s) in color-api.yaml to the Kubernetes API server so the cluster will create or update the described objects (in this case the backend color-api Pod or the workload that manages it). ```kubectl apply``` computes the desired state from the file and merges it with the cluster’s current state, triggering scheduling, image pulls, and container startup; it’s the standard way to create resources from YAML while preserving future updates through re-applying changes.

```
kubectl get pods
```
This lists all Pods in the current namespace, showing each Pod’s name, readiness, STATUS (Pending/Running/Completed/CrashLoopBackOff, etc.), restarts, and age; it’s the quick, first-check command to verify whether your newly created color-api (and any other) Pods exist and what their runtime state is. Use it to spot scheduling problems, crash loops, or to confirm that containers have reached the Running state.

#### Add Extra Columns
```
kubectl get pods -L app -L tier
```
The **-L** flags ask kubectl to add the app and tier label values as extra columns in the Pods table, so you can see each Pod’s label metadata inline with status information. This makes it easy to confirm that Pods were created with the intended labels (for example app=color-api, tier=backend or tier=frontend) and to visually group or distinguish backend vs frontend workloads without running a separate kubectl describe or label query.

#### Filter Pods
```
kubectl get pods -l app=color-api -l tier=frontend
kubectl get pods -L app -L tier -l app=color-api -l tier=frontend
```

```
kubectl get pods -l 'app=color-api,tier=frontend'
kubectl get pods -L app -L tier -l 'app=color-api,tier=frontend'
```

Using **-l** applies label selectors to filter the output to only Pods that match all provided label expressions **(multiple -l act as an AND)**. The first form returns only Pods that have app=color-api and tier=frontend; the second adds **-L** to include the app and tier columns in the output so you both filter to the matching set and see their label values. Label selectors are the primary way to target subsets of resources for inspection, service selection, and operations.

```
kubectl get pods -l 'tier in (backend, frontend)'
kubectl get pods -L app -L tier -l 'tier in (backend, frontend)'
```

```
kubectl get pods -l 'tier notin (frontend)'
kubectl get pods -L app -L tier -l 'tier notin (frontend)'
```

#### Create a deployment
```
kubectl apply -f color-depl.yaml
```

```
kubectl get pods -L tier -L managed
```

#### Clear Resources
```
kubectl delete -f color-depl.yaml -f color-api.yaml
```

## Annotations
Annotations in Kubernetes are key–value metadata attached to objects, similar to labels, but they are intended for non-identifying, descriptive, or operational information rather than selection or grouping. Kubernetes itself does not interpret annotation values for scheduling or service discovery; instead, annotations are consumed by tools, controllers, and external systems such as ingress controllers, service meshes, monitoring agents, or GitOps operators. Because annotations are not used in selectors, they can store large or complex data like JSON snippets, configuration hints, checksums, or documentation links without affecting workload behavior.

In practice, annotations are widely used to influence platform behavior and integrations without changing application code or resource structure. Common examples include configuring ingress behavior (TLS, rewrites, rate limits), triggering rolling restarts via checksum changes, attaching ownership or runbook URLs, and passing metadata to observability and security tools. This makes annotations a powerful extension mechanism in Kubernetes, enabling teams to enrich resources with operational context while keeping labels clean, stable, and focused on identity.

#### Summary:
Annotations add useful information and configuration to resources

Annotations are key-value pairs attached to Kubernetes objects, just like labels. Unlike labels, annotations are not supposed to store identifying metadata, and they are often used by tools or the Kubernetes system itself.

#### Common use-cases:

• **Tool-specific metadata and configuration:** external tools (monitoring systems, logging agents) leverage annotations to attach custom data to resources (contigurations, metrics conection enapolnts, etc.)

• **Configuration for ingress controllers:** used to configure ingress controllers (traffic routing, SSL termination, security settings). For example, you can define path rewrites or custom load balancing rules via annotations.

• **Storing build and version information:** annotations can store metadata such as build timestamps, version numbers, or Git commit hashes.

• **Runtime configuration for operators:** Kubernetes operators or controllers can use annotations to customize runtime behavior for specific resources.