# Namespaces
Namespaces in Kubernetes are a logical isolation mechanism used to partition a single cluster into multiple virtual environments. They provide a scope for names, meaning resources like Pods, Services, and ConfigMaps can share the same name as long as they exist in different namespaces. This is especially useful for separating environments (dev, staging, prod), teams, or applications while sharing the same cluster infrastructure.

Beyond naming isolation, namespaces are a key building block for multi-tenancy and operational control. They are used with RBAC to restrict who can access or modify resources, with ResourceQuotas and LimitRanges to control CPU and memory consumption, and with NetworkPolicies to limit traffic between workloads. While namespaces do not provide strong security isolation by themselves, they are essential for organizing clusters at scale and enforcing governance, cost control, and operational boundaries.

#### Summary
Improve isolation for groups of resources

• Namespaces provide a way to divide cluster resources between multiple users, teams, applications, or environments. It allows for resource isolation and helps organize workloads in large Kubernetes clusters.

• Namespaces enable logical isolation of resources within the same physical cluster.

• **Initial namespaces:** default, kube-system, kube-public, and kube-node-Lease.

#### Common Use-Cases:

• **Multi-tenant clusters:** Each team can take care of their applications, and keep their resources (pods, services, etc.) logically separated.

• **Environment separation:** Each environment can have its own resources, with different policies and quotas applied.

• **Resource Quotas:** We wish to limit the CPU, memory, and number of resources that a namespace can use. This prevents one team or environment from monopolizing cluster resources.

• **Security and Access Control:** We wish to limit user or service account access to specific resources via RBAC mechanisms. This ensures that users or services can only access resources within their allowed namespaces.

#### Using namespaces:
- We must inform in which namespace we wish to create our resources
- We can set a current namespace for all kubectl commands, or pass it explicitly in each command
- Service communication requires the fully qualified domain name (FQDN) of the service

#### Best practices around namespaces:
- Don't overuse them: just because we can create namespaces, doesn't mean we should. Consider whether there is a solid case for logically isolating the cluster resources.
- Combine namespaces with RBAC to improve security around resources deployed in each
nartesodce.
- Limit the resources a namespace can use by implementing resource quotas to namespaces and resource requests and limits to their respective resources.
- Use meaningful dimensions to define the namespaces, and make sure they align with the overall

## Example

### Create a Namespace
```
kubectl apply -f dev-ns.yaml
```
Applying the namespace manifest creates a logical boundary named dev inside the cluster, allowing resources to be isolated by environment or team. Namespaces do not create new clusters, but they provide scoped naming and a foundation for access control, quotas, and policies. This step prepares the cluster for environment-specific workloads.

#### Listing Existing Namespaces
```
kubectl get ns
kubectl get namespace
```
The ```kubectl get ns``` and ```kubectl get namespace``` commands display all namespaces currently present in the cluster. This confirms that the dev namespace was successfully created and shows system namespaces such as default and kube-system. It helps verify cluster structure before deploying workloads.

#### Viewing Pods in kube-system
```
kubectl get pods --namespace kube-system
```
Listing Pods in the kube-system namespace shows core Kubernetes components like CoreDNS and kube-proxy. These Pods are managed by Kubernetes itself and are critical for cluster operation. This step reinforces that namespaces are used to separate system workloads from application workloads.

#### Deploying color-api into the dev Namespace
```
kubectl apply -f color-api-ns-dev.yaml
```
Applying the color-api-ns-dev.yaml manifest deploys the application specifically into the dev namespace. This explicitly scopes the Pod to that namespace rather than the default one. It demonstrates how workloads can be isolated without changing cluster-wide configuration.

#### Querying Pods Without a Namespace
```
kubectl get pods
```
Running ```kubectl get pods``` without specifying a namespace queries only the current namespace, which is **default** by default. Since the Pod was created in dev, no results are returned. This highlights how namespace scoping affects visibility and prevents accidental cross-namespace operations.

#### Querying Pods in the dev Namespace
```
kubectl get pods -n dev
kubectl get pods --namespace dev
```
Using **-n dev** or **--namespace dev** explicitly targets the dev namespace and returns the color-api Pod. This confirms the Pod exists and is running in the intended namespace. Explicit namespace flags are a safe practice when working across multiple environments.

#### Checking the Current Kubernetes Context
```
kubectl config current-context
```
This command shows which cluster, user, and namespace are currently active. This is important because kubectl defaults to the namespace defined in the current context. Understanding the active context helps prevent accidental operations in the wrong namespace.

#### Setting the Default Namespace to dev
```
kubectl config set-context --current --namespace=dev
```
Updating the current context to use the dev namespace changes kubectl’s default behavior. After this, all namespace-scoped commands automatically target dev unless overridden. This improves productivity when working heavily within a single namespace.

#### Accessing Pods After Context Switch
```
kubectl get pods
kubectl describe pod color-api
```
Once the namespace is set to dev, running kubectl get pods and describing the Pod works without specifying a namespace. This confirms the context change was successful. It also shows how kubectl context simplifies day-to-day operations.

#### Viewing kubeconfig Details
```
kubectl config view
```
This command displays the full kubeconfig, including contexts, clusters, users, and default namespaces. This is useful for debugging access issues and understanding how kubectl determines where commands are executed. It provides visibility into client-side configuration.

#### Listing Pods Across All Namespaces
```
kubectl get pods -A
kubectl get pods --all-namespaces
```
Using **-A** or **--all-namespaces** retrieves Pods from every namespace in the cluster. This is helpful for cluster-wide debugging, audits, or operational monitoring. It clearly illustrates how namespaces segment resources while still allowing global visibility when needed.

#### Resetting the Namespace to default
```
kubectl config set-context --current --namespace=default
```
Switching the context back to the **default** namespace restores kubectl’s original behavior. This is important after finishing work in a non-default namespace to avoid accidental changes. It reinforces good operational hygiene.

#### Deleting the Namespace
```
kubectl delete -f dev-ns.yaml
```
Deleting the namespace removes all resources within it, including Pods, Services, and ConfigMaps. This demonstrates the power and risk of namespace deletion, as it acts as a bulk cleanup operation. Because of its impact, ***deletion should be restricted using RBAC*** to prevent accidental or unauthorized removal.

### Cross-Namespace Service Communication

#### Creating the traffic generator in the default namespace
```
kubectl apply -f traffic-generator.yaml 
```
Applying the traffic-generator.yaml manifest deploys the traffic generator Pod into the default namespace, making it an internal client that represents a workload running outside the dev environment. This setup is intentional to demonstrate cross-namespace communication rather than same-namespace access. It establishes a clear separation between the client and the service being called.

#### Creating the dev namespace, color-api, and its Service
```
kubectl apply -f dev-ns.yaml -f color-api-svc-dev.yaml -f color-api-ns-dev.yaml 
```
Applying the namespace, Service, and Deployment manifests together creates an isolated **dev** namespace and deploys the color-api application within it. The Service exposes the Pods inside the namespace using a stable virtual IP and DNS name. This step ensures the application is reachable only through Kubernetes service discovery rather than direct Pod access.

#### Verifying Pods and Services in the dev namespace
```
kubectl get pods,svc -n dev
```
Running ```kubectl get pods,svc -n dev``` confirms that both the color-api Pods and the corresponding Service are running in the dev namespace. This validation step ensures the backend application is healthy and properly exposed before testing cross-namespace traffic. It also confirms that namespace scoping is correctly applied.

#### Using the fully qualified domain name (FQDN)
```
<service-name>.<namespace>.svc.cluster.local/<path>
```
When a Pod in the default namespace accesses a Service in the dev namespace, it must use the full Kubernetes DNS name in the format ```<service-name>.<namespace>.svc.cluster.local/<path>```. This explicitly identifies the target Service’s namespace and avoids ambiguity with similarly named Services elsewhere. Using FQDNs is a best practice for clarity, portability, and reliable cross-namespace communication.

#### Observing traffic generator logs
```
kubectl logs traffic-generator
kubectl logs -f traffic-generator
```
Checking the logs of the traffic generator Pod reveals whether requests to the color-api Service are succeeding or failing. This step verifies actual runtime connectivity rather than just resource creation. Successful responses confirm that Kubernetes DNS and networking are functioning across namespaces.

### Clear Resources
```
kubectl delete -f dev-ns.yaml -f color-api-svc-dev.yaml -f color-api-ns-dev.yaml 
```

