## Pods with Dockerfile

- [Create and Run Docker Container](#create-and-run-docker-container)
- [Run the color-api Pod](#run-the-color-api-pod)
- [Test Service connectivity from another Pod](#test-service-connectivity-from-another-pod)
- [Cleanup Resources](#cleanup-resources)

#### Create and Run Docker Container

##### Create a docker image (run command under color-api folder)
```
docker build -t color-api-image .
```
This command builds a Docker image from the Dockerfile located in the color-api folder.
- **docker build** tells Docker to create an image
- **-t** color-api-image assigns a name (tag) to the image
- **.** specifies the build context (current directory)

During this process, Docker:
- Reads the Dockerfile instructions
- Packages application code and dependencies
- Produces an immutable image that can run anywhere Docker is available

##### List Docker images: 
```
docker images 
```
Displays all Docker images stored locally. You can verify that color-api-image was created successfully and inspect details like image ID, size, and creation time.

##### Run the container
```
docker run -p 3000:80 --name color-api color-api-image
```
This starts a container from the color-api-image image.
- **-p 3000:80** maps port 80 inside the container to 3000 on your host
- **--name color-api gives** the container a readable name
- color-api-image specifies the image to run

The application inside the container now listens on port 80, but is accessible via localhost:3000.

##### Test the connection
```
curl localhost:3000
```
This sends an HTTP request to the running container through the port mapping. A successful response confirms:
- The container is running
- Port mapping is correct
- The application is serving traffic properly

##### Create a versioned Docker image
```
docker build -t selcouthonism/color-api-image:1.0.0 .
```
This rebuilds the image with a fully qualified name and version tag.
- selcouthonism → Docker Hub username or organization
- color-api-image → repository name
- 1.0.0 → version tag

Versioning images is a best practice for reproducibility, rollbacks, and CI/CD pipelines.

##### Login to Docker Hub
```
docker login
```
Authenticates your local Docker client with Docker Hub. This step is required before pushing images to a remote registry. Credentials are stored securely and reused for future pushes.

##### Push image to Docker Hub
```
docker push selcouthonism/color-api-image:1.0.0
```
Uploads the image to Docker Hub so it can be pulled from anywhere.
- The image is split into layers
- Only missing layers are uploaded
- The image becomes publicly or privately available (depending on repo settings)

Once pushed, the image can be used by:
- Other developers
- CI/CD pipelines
- Kubernetes clusters (kubectl, Helm, etc.)

#### Run the color-api Pod
```
kubectl run color-api --image=selcouthonism/color-api-image:1.0.0
```
This command creates a standalone Pod named color-api using the Docker image selcouthonism/color-api-image:1.0.0 pulled from Docker Hub.

What happens internally:
- The request is sent to the Kubernetes API server
- The scheduler assigns the Pod to a node
- The kubelet pulls the image from the registry
- The container starts inside the Pod

No Deployment or Service is created—this Pod is not self-healing and will not be recreated if it crashes.

##### View logs and detailed Pod information
```
kubectl logs color-api
```
Fetches stdout and stderr output from the container inside the Pod. This is how you verify that your application started correctly and is producing expected output.

```
kubectl describe pod color-api
```
Shows detailed runtime information such as:
- Node placement
- Container image and ports
- Environment variables
- Events (image pull, start, failures)

This command is essential for debugging startup and runtime issues.

Pod status and IP:
```
Status:           Running
IP:               10.244.0.8
```
- Status: Running → The container is successfully running
- IP: 10.244.0.8 → This is the Pod’s internal cluster IP, assigned by the CNI plugin

Important characteristics of Pod IPs:
- Only reachable inside the Kubernetes cluster
- Can change if the Pod is deleted and recreated
- Should not be used as a stable endpoint in production

#### Test Service connectivity from another Pod

##### Run an interactive Alpine Pod
```
kubectl run -it alpine --image=alpine:3.20 sh
apk --update add curl
```
This starts a lightweight debug Pod and installs curl to test networking inside the cluster. This is a standard operational debugging technique.

##### Access color-api via Pod IP (from Alpine)
```
curl 10.244.0.8
```
This command is run from another Pod (an Alpine debug Pod). It verifies:
- Pod-to-Pod networking is working
- The application is listening on the expected port
- The CNI networking layer is functioning correctly
- This is a valid debugging technique, but direct Pod IP access is not recommended for real applications. Services should be used instead to provide stability and DNS-based discovery.

#### Cleanup Resources

##### Delete Pods
```
kubectl delete pod alpine color-api --force --grace-period=0
```
Deletes both Pods immediately
- **--force** bypasses graceful shutdown (dev only)
- **--grace-period=0** skips waiting for SIGTERM handling

Since these Pods were created directly (not via a Deployment), they are permanently removed and will not be recreated.