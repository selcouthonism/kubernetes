# kubectl & minikube

## kubectl
**kubectl** is the command-line interface (CLI) for interacting with a Kubernetes cluster. It communicates directly with the Kubernetes API server and allows users to create, update, delete, and inspect cluster resources such as Pods, Deployments, Services, ConfigMaps, and Secrets. 

kubectl is declarative by design: you describe the desired state of your application (via commands or YAML manifests), and Kubernetes works to make the cluster match that state.

From an operational perspective, kubectl is used for day-to-day cluster management and troubleshooting. It supports applying manifests (***kubectl apply***), querying cluster state (***kubectl get***, ***kubectl describe***), debugging (***kubectl logs***, ***kubectl exec***), and managing access via contexts and namespaces. kubectl itself does not run Kubernetes—it is simply a client. The cluster can be local, on-prem, or in the cloud; as long as there is an API server, kubectl can manage it.

## minikube
Minikube is a lightweight tool that runs a local, single-node Kubernetes cluster on your machine for development, learning, and testing. It provisions the Kubernetes control plane and worker components inside a VM or container runtime (Docker, Podman, etc.), handling setup that would otherwise be complex. Minikube is not meant for production; its goal is to provide a fast, realistic Kubernetes environment on a laptop.

Operationally, Minikube simplifies local workflows by integrating tightly with kubectl. When you run ***minikube start***, it automatically configures kubectl context, networking, and cluster access. It also provides convenience commands like minikube service, minikube dashboard, and minikube addons to expose services, visualize resources, and enable common components such as ingress or metrics-server.

- Creates a single-node Kubernetes cluster inside a VM or container on your local machine.
- Includes everything you need: kubelet, kubeadm, kube-apiserver, etcd, etc.
- Gives you a working kubectl config out of the box.
- Simulates a full Kubernetes environment — supports LoadBalancers, Ingress, CSI, RBAC, Metrics Server, and more.

Why Use Minikube?
- Local & offline: Great for disconnected or resource-limited environments.
- Easy setup: No cloud, billing, or provisioning needed.
- Supports real Kubernetes behavior (unlike simpler emulators like kind).
- Pluggable backends: Docker, containerd, Hyperkit, KVM, VirtualBox, WSL2.

When Not to Use Minikube?
- For production — it’s single-node and not HA.
- For multi-node simulations — consider tools like kind, k3d, or full cloud clusters.
- If you're using GitHub Actions or CI pipelines — lighter tools like kind or microk8s may be better.

## Relationship between kubectl and Minikube
Think of Minikube as the Kubernetes cluster and kubectl as the remote control. Minikube creates and runs the cluster locally; kubectl is the standard interface used to manage that cluster, exactly the same way you would manage a production Kubernetes cluster in AWS, GCP, or on-prem. This separation is intentional and mirrors real-world Kubernetes operations, making Minikube an ideal learning and development environment.

## Setup

#### Install kubectl on macOS
```
brew install kubectl
```

#### Install Minikube on macOS
```
brew install minikube
```

## minikube Commands

#### Start minikube cluster:
```
minikube start
```
- Downloads a base Kubernetes image.
- Spins up a VM or container (e.g., with Docker, Podman, Hyper-V, VirtualBox).
- Bootstraps a single-node Kubernetes cluster inside it.
- Configures your local kubectl to talk to it.

#### Start a cluster
```
minikube start
```
This command creates and starts a local Kubernetes cluster using Minikube. Under the hood, Minikube provisions a virtual machine or container (Docker, Podman, etc.), installs Kubernetes components (control plane + worker node), configures networking, and sets up kubectl context automatically. After this completes, you have a fully functional single-node Kubernetes cluster suitable for local development and learning.

#### Stop cluster
```
minikube stop
```
This stops the running Minikube cluster without deleting it. The VM or container is shut down, which frees CPU and memory resources on your machine. Cluster state (Pods, Deployments, configs) is preserved, allowing you to resume later with ***minikube start***.

#### Delete cluster
```
minikube delete
```
This completely removes the Minikube cluster, including the VM/container, Kubernetes state, networking, and stored resources. Use this when you want a clean slate, for example after experiments or when troubleshooting cluster-level issues.

## kubectl Commands

#### Check version
```
kubectl version
```
This displays both:
- Client version → your local kubectl binary
- Server version → the Kubernetes API server running inside Minikube

Checking version compatibility is important because a very old or very new kubectl may not work correctly with the cluster. Kubernetes guarantees compatibility within roughly ±1 minor version.

#### Confirm kubectl conntected to minikube
````
kubectl config current-context
````
This shows which Kubernetes context kubectl is currently using. If it returns something like minikube, then kubectl is correctly configured to talk to your Minikube cluster. Contexts define which cluster, user, and namespace kubectl communicates with.

```
kubectl config view
```
This command gives an overview of the current context and cluster settings.

#### Deploy an app
```
kubectl create deployment hello --image=k8s.gcr.io/echoserver:1.4
```
This creates a Deployment named hello that runs a Pod using the echoserver container image. 

A Deployment:
- Manages Pod lifecycle
- Ensures desired replica count (default = 1)
- Enables rolling updates and self-healing

At this stage, the Pod exists but is not accessible from outside the cluster.

#### Network info
```
kubectl cluster-info
```
This shows basic information about the cluster, including:
- Kubernetes API server endpoint
- Core services like CoreDNS

It’s useful for confirming the cluster is up and networking components are running.

#### Get Nodes
```
kubectl get nodes
```
This lists all worker nodes in the cluster. In Minikube, you typically see a single node that plays both control plane and worker roles. The node status (Ready) indicates whether it can run workloads.

#### Get namespaces
```
kubectl get namespaces
```
This lists all namespaces in the cluster, such as:
- default
- kube-system
- kube-public
- kube-node-lease

Namespaces provide logical isolation for resources and are commonly used to separate environments or teams.

#### Get the pods A: every namespace
```
kubectl get pods -A
```
The ***-A*** (or ***--all-namespaces***) flag shows Pods running across every namespace, including system components like CoreDNS and kube-proxy. This is useful for debugging and understanding what Kubernetes runs internally.

#### Expose it
```
kubectl expose deployment hello --type=NodePort --port=8080
```
The command creates a Service of type NodePort, which:
- Assigns a stable virtual IP
- Exposes the Deployment on a port accessible from outside the cluster

```
minikube service hello
```
The command is Minikube-specific. It automatically:
- Finds the assigned NodePort
- Opens the service URL in your browser or prints it

This allows you to access the application from your local machine without configuring a cloud load balancer.

### Create namespace
https://github.com/LinkedInLearning/learning-kubernetes-3212391/tree/main

https://github.com/PacktPublishing/Docker-and-Kubernetes-Masterclass-From-Beginner-to-Advanced/blob/main/docker-course-main/docker-course-main/multistage-builds/Dockerfile

namespace.yaml
```
---
apiVersion: v1
kind: Namespace
metadata:
    name: development
---
apiVersion: v1
kind: Namespace
metadata:
    name: production
```

```
kubectl apply -f namespace.yaml
```

### Delete namespace
```
kubectl delete -f namespace.yaml
```

## Kubernete Security Check
synk checks the security settings of deployment.yaml file.

```
snyk iac test deployment.yaml
```