# Pods
- [Pods with kubectl](#pods-with-kubectl)
- [Pods with Services](#pods-with-services)

## Pods with kubectl

#### Check kubectl and cluster version
```
kubectl version
```
This command shows:
- Client version → your local kubectl
- Server version → the Kubernetes API server you’re connected to

It verifies that kubectl can communicate with the cluster and that the client/server versions are compatible.

#### Check current kubectl context
```
kubectl config current-context
```
This shows which Kubernetes context kubectl is currently using. A context defines:
- Which cluster to talk to
- Which user credentials to use
- Which default namespace to operate in

If this does not point to minikube, your commands may be sent to the wrong cluster.

#### Update context:
```
kubectl config set-context minikube
kubectl config use-context minikube
```
This updates (or creates) a context named minikube. In practice, Minikube usually configures this automatically. Contexts allow you to switch safely between multiple clusters (local, staging, production) without changing commands.

#### View help for kubectl run
```
kubectl run --help
```
Displays usage instructions and flags for the kubectl run command. This command is commonly used for:
- Creating simple Pods
- Running one-off containers for debugging
- Launching interactive shells inside containers

It’s especially useful to understand default behaviors (restart policy, naming, etc.).

#### Run an NGINX Pod
```
kubectl run nginx --image=nginx:1.27.0
```
This creates a Pod named nginx running a single container based on the nginx:1.27.0 image. No Service or Deployment is created. Just a standalone Pod. The scheduler assigns it to a node, the kubelet pulls the image, and the container starts.

#### List Pods
```
kubectl get pods
```
Lists Pods in the current namespace (default unless changed). You can see:
- Pod name
- Readiness status
- Current phase (Pending, Running, etc.)
- Restart count

This confirms that the NGINX Pod is running.

#### Describe the NGINX Pod
```
kubectl describe pod nginx
```
This will give you a wealth of information about the nginx pod, including its events, status, IP address, and resource usage. It's incredibly useful for in-depth inspection.

Provides detailed information about the Pod, including:
- Node assignment
- Container image and ports
- Environment variables
- Events (image pull, scheduling, restarts)

This is one of the most important debugging commands in Kubernetes.

##### Pod IP Address
```
IPs:
  IP:  10.244.0.5
```
This is the Pod IP, assigned by the cluster’s CNI (Container Network Interface).
- It is only reachable inside the cluster
- Other Pods can access it directly
- External clients cannot access it without a Service
- Pod IPs are ephemeral and change if the Pod is recreated.

When a pod is deleted and recreated, it will get a new IP address. This is a fundamental aspect of how pods are designed to be ephemeral.

Kubernetes Services provide a stable IP address (the Cluster IP) and a DNS name that remains constant even when the underlying pods are deleted and recreated. This abstraction is key to reliable communication within a Kubernetes cluster.

#### Test Service connectivity from another Pod

##### Run an interactive Alpine Pod
```
kubectl run -it alpine --image=alpine:3.20 sh
```
This starts a temporary interactive Pod running Alpine Linux and opens a shell (sh). This is a common technique for:
- Network debugging
- DNS testing
- Service connectivity checks
- The **-it** flags allocate a terminal and keep STDIN open.

##### Install curl inside Alpine
```
apk --update add curl
```
Installs curl using Alpine’s package manager. This tool is needed to test HTTP connectivity from inside the cluster.

##### Access NGINX via Pod IP (inside Alpine)
```
curl 10.244.0.5
```
This works because:
- Both Pods are in the same Kubernetes cluster
- Pod-to-Pod networking is flat and routable

This confirms that direct Pod IP communication is functioning. 

Note: Direct Pod access is for testing. Services are required for production.

#### View Pod logs
```
kubectl logs nginx
```
Displays logs from the default container in the nginx Pod. This is equivalent to reading stdout and stderr of the container process.

#### View logs for a specific container
```
kubectl logs nginx --container=nginx
```
Used when a Pod contains multiple containers. You must specify which container’s logs you want. In this case, the Pod has only one container, so the output is the same.

#### View delete command help
```
kubectl delete --help
```
Shows all resource types that can be deleted and supported flags. This helps prevent accidental deletion of the wrong resource, especially important in production clusters.

#### Delete the Alpine Pod
```
kubectl delete pod alpine
```
This deletes the alpine Pod. Kubernetes:
- Sends a SIGTERM
- Waits for graceful shutdown
- Removes the Pod completely

Because this Pod was created directly (not by a controller), it will not be recreated.

## Pods with services

#### Show help for exposing Pods
```
kubectl expose pod --help
```
This command displays usage details for exposing a Pod via a Service. It shows supported Service types (ClusterIP, NodePort, LoadBalancer), port mappings, and selectors. This is important because Pods are ephemeral, and Services provide a stable abstraction over changing Pod IPs.

#### Expose the NGINX Pod
```
kubectl expose pod nginx --type=NodePort --port=80
kubectl expose pod nginx --type=NodePort --port=80 --name=nginx-svc
```
This creates a Service named nginx/nginx-svc that:
- Targets the nginx Pod via labels
- Exposes port 80 inside the cluster
- Allocates a NodePort (in the 30000–32767 range) for external access

The Service becomes the stable entry point (Services provide stable IPs and DNS names), even if the Pod is restarted or replaced.

The Service abstraction is the cornerstone for providing a stable and reliable communication mechanism in Kubernetes, decoupling the ephemeral nature of pods from the consistent access needed by other applications. It's what allows your applications to find and talk to each other without worrying about changing pod IPs.

#### List Services
```
kubectl get service
```
This shows all Services in the current namespace.

Example output:
```
kubernetes   ClusterIP   10.96.0.1      <none>        443/TCP        4h58m
nginx        NodePort    10.97.63.216   <none>        80:30747/TCP   4m17s
nginx-svc    NodePort    10.108.126.184 <none>        80:32361/TCP   4s
```

Explanation:
- kubernetes: A default internal Service for the API server
- nginx: Your Service exposing the NGINX Pod

Fields:
- ClusterIP (10.97.63.216) → Stable, virtual IP for **in-cluster** access
- NodePort (30747) → Port exposed on every node for external access

- ClusterIP is stable for the lifetime of the Service
- Pod IPs change when Pods are recreated
- Services decouple clients from Pod lifecycle

**Service vs Pod IP:**

The ClusterIP remains constant as long as the Service exists. If the Pod dies and a new Pod replaces it with a different IP, the Service automatically updates its endpoints. Clients never need to know about Pod IP changes.

#### Inspect Services
```
kubectl describe service nginx
kubectl describe service nginx-svc
```

##### Troubleshooting Communication Issues: 
Imagine a scenario where a developer is experiencing communication problems between two pods (inter-pod communication), even though a service has been set up. He suspects the issue might be related to how the service is exposing the pods. 

- inspect the service in more detail
- check if a service is correctly routing traffic to pods

**Endpoints section:** lists the IP addresses and ports of the pods that the service is currently routing traffic to. If the Endpoints list is empty, or if it doesn't show the expected pod IPs, then there's a problem with the service's selector not matching any running pods.

The key part of a service definition that tells it which pods to target is the **selector**. The service uses this selector to find pods that have matching labels. If the selector in the service definition doesn't match the labels on the pods, the service won't have any endpoints.

Check the service's selector using ***kubectl describe service [service-name]*** and then compare those labels to the labels on the actual pods using ***kubectl get pods --show-labels*** or ***kubectl describe pod [pod-name]***.

If the Endpoints section was empty (assuming the pods are running correctly):

If the selector in the service didn't match the labels on the pods, the most direct fix would be to edit the service definition to ensure its selector matches the labels of the pods it's supposed to expose. This can often be done using ***kubectl edit service [service-name]***.

Once the selector is corrected, the service should automatically pick up the matching pods and populate its Endpoints.

Beyond the selector, you should also consider the targetPort in the service definition. This specifies the port on the pod that the service will send traffic to. If the targetPort in the service doesn't match the port the application inside the pod is listening on, communication will fail.

Verify this by checking the pod's container port definition (using ***kubectl describe pod [pod-name]***) and comparing it to the targetPort in the service definition.

#### Test Service connectivity from another Pod

##### Run an interactive Alpine Pod
```
kubectl run -it alpine --image=alpine:3.20 sh
apk --update add curl
```
This starts a lightweight debug Pod and installs curl to test networking inside the cluster. This is a standard operational debugging technique.

##### Access NGINX via ClusterIP
```
curl 10.97.63.216
```
This confirms:
- The Service is routing traffic correctly
- kube-proxy is forwarding requests to the backend Pod
- Service virtual IP is functioning as expected

##### Access NGINX via Service DNS
```
curl nginx
```
This uses Kubernetes DNS (CoreDNS) to resolve the Service name nginx to its ClusterIP. This is the recommended way for Pods to communicate with each other in Kubernetes.

Best practice: Always use Service DNS names, not IPs.

#### Cleanup resources

##### Delete the Service
```
kubectl delete service nginx
```
This removes the Service and its stable ClusterIP. After this, traffic to nginx via DNS or IP will no longer work.

#####  Delete Pods
```
kubectl delete pod alpine
kubectl delete pod nginx
```
This removes both Pods. Since these Pods were created directly (not via a Deployment), they are not recreated automatically.


#### Notes:
- Pods are ephemeral and unreliable as network endpoints
- Services provide stable IPs and DNS names
- kube-proxy implements Service routing and load balancing
- ClusterIP is for internal access; NodePort is for basic external access
- DNS-based service discovery is fundamental in Kubernetes