# Pod
A Pod is the smallest and most fundamental execution unit in Kubernetes. It represents one or more containers that must run together on the same node and share the same network namespace (IP address and ports), storage volumes, and lifecycle. In practice, most Pods run a single container, while multi-container Pods are used for tightly coupled patterns such as sidecars (e.g., logging, proxy, or service mesh agents).

Pods are ephemeral by design which means they are not meant to be durable or long-lived entities. If a Pod fails or is deleted, Kubernetes does not recreate the same Pod; instead, higher-level controllers like Deployments, ReplicaSets, or StatefulSets create new Pods to replace it. This design enforces immutability and encourages resilient application architectures.

### Pod Lifecycle Overview
The Pod lifecycle describes the sequence of states a Pod goes through from creation to termination. Kubernetes tracks Pod state using a **status.phase** field, while controllers and kubelet handle transitions. Understanding this lifecycle is critical for debugging, scaling, and designing reliable workloads.

Understanding Pods and their lifecycle is foundational to operating Kubernetes reliably in production.
- Pods are not self-healing; controllers provide resilience
- Pods are immutable and disposable
- Pod lifecycle phases reflect execution state, not health
- Readiness and liveness probes control traffic and restarts

#### Pod Lifecycle Phases
##### 1. Pending
A Pod enters the Pending phase after it is accepted by the API server but before it is running. 

During this phase:
- The scheduler has not yet assigned the Pod to a node or
- The node is assigned, but container images are still being pulled or resources are not yet available

Common issues here include insufficient CPU/memory or image pull failures.

##### 2. Running
The Pod is in the Running phase when:
- It has been scheduled to a node
- At least one container is running

Containers may still restart due to crashes, but as long as one container is running, the Pod remains in this phase. Readiness and liveness probes determine whether traffic should be sent to the Pod.

##### 3. Succeeded
A Pod enters the Succeeded phase when all containers terminate successfully (exit code 0) and will not restart. This is typical for **batch jobs**, **cron jobs**, or **one-off tasks** where successful completion is expected.

##### 4. Failed
A Pod is marked Failed when:
- All containers have terminated
- At least one container exited with a non-zero exit code

This indicates an error condition. Debugging typically involves inspecting container logs and exit codes.

##### 5. Unknown
The Unknown phase means the Pod state cannot be determined, usually due to:
- Network partition
- Node communication failure with the API server

This often signals underlying infrastructure or node-level problems.

#### Pod Termination Lifecycle
When a Pod is deleted (manually or by a controller), Kubernetes performs a graceful termination:
1. The Pod is marked Terminating
2. SIGTERM is sent to containers
3. The Pod waits for terminationGracePeriodSeconds
4. Containers are force-killed (SIGKILL) if they do not exit in time

Proper shutdown handling in applications is critical to avoid data loss or failed requests.

#### Restart Policies
Pods define a restartPolicy that controls container restarts:
- **Always (default)**: used by Deployments
- **OnFailure**: used by Jobs
- **Never**: used for one-off executions

This policy applies to containers, not Pods themselves.